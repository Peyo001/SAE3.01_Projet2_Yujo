<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room 3D - {{ room.getNom() }}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { width: 100%; height: 100%; background: #0a0e27; font-family: 'Segoe UI', sans-serif; color: #fff; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .panel { position: absolute; background: rgba(10, 14, 39, 0.92); border: 2px solid #ff0080; border-radius: 10px; padding: 15px; z-index: 100; backdrop-filter: blur(8px); }
        .top-bar { top: 15px; left: 50%; transform: translateX(-50%); max-width: 90%; display: flex; justify-content: center; align-items: center; gap: 20px; }
        .title { font-size: 20px; font-weight: 700; color: #ff0080; white-space: nowrap; }
        .btns { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        .btn { padding: 8px 14px; background: linear-gradient(135deg, #e53282, #ff0080); border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 12px; transition: all 0.2s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(229, 50, 130, 0.4); }
        .btn.active { background: linear-gradient(135deg, #4b2cb7, #8a2be2); box-shadow: 0 0 20px rgba(138, 43, 226, 0.6); }
        .sidebar-left { bottom: 15px; left: 15px; width: 280px; max-height: 70vh; overflow-y: auto; }
        .sidebar-right { bottom: 15px; right: 15px; width: 280px; }
        .sidebar-left h3, .sidebar-right h3 { color: #ff0080; margin-bottom: 12px; font-size: 14px; font-weight: 700; }
        .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .obj-btn { padding: 10px; background: linear-gradient(135deg, #2a2a4e, #4a2a7e); border: 2px solid rgba(229, 50, 130, 0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 18px; text-align: center; transition: all 0.2s; }
        .obj-btn:hover { border-color: #ff0080; background: linear-gradient(135deg, #3a3a5e, #5a3a8e); box-shadow: 0 0 15px rgba(229, 50, 130, 0.3); }
        .info { font-size: 12px; padding: 8px; background: rgba(229, 50, 130, 0.1); border-radius: 6px; margin-bottom: 6px; border-left: 3px solid #ff0080; }
        .info-label { color: #aaa; }
        .info-value { color: #4ade80; font-weight: 700; margin-left: 8px; }
        .hint { font-size: 11px; color: #888; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); line-height: 1.4; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: rgba(229, 50, 130, 0.5); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(229, 50, 130, 0.8); }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<!-- Top Bar -->
<div class="panel top-bar">
    <h1 class="title">{{ room.getNom() }} üè†</h1>
    <div class="btns">
        <button class="btn" onclick="resetCam()">üì∑ Vue</button>
        <button class="btn" id="rotBtn" onclick="toggleRotate()">üîÑ D√©plac.</button>
        <button class="btn" onclick="saveRoom()">üíæ Save</button>
        <button class="btn" onclick="clearRoom()">‚Üª Reset</button>
    </div>
</div>

<!-- Objects -->
<div class="panel sidebar-left">
    <h3>üì¶ Objets</h3>
    <div class="grid" id="grid"></div>
</div>

<!-- Info -->
<div class="panel sidebar-right">
    <h3>‚ÑπÔ∏è Infos</h3>
    <div class="info"><span class="info-label">Mode:</span><span class="info-value" id="mode">Cam√©ra</span></div>
    <div class="info"><span class="info-label">Objets:</span><span class="info-value" id="count">0</span></div>
    <div class="info"><span class="info-label">FPS:</span><span class="info-value" id="fps">60</span></div>
    <div class="info"><span class="info-label">Pos:</span><span class="info-value" id="pos">0,0,0</span></div>
    <div class="info"><span class="info-label">Rot:</span><span class="info-value" id="rot">0¬∞</span></div>
    <div class="hint">
        <strong>Contr√¥les:</strong><br/>
        ‚Ä¢ Souris = Cam/Obj<br/>
        ‚Ä¢ R = Toggle Mode<br/>
        ‚Ä¢ Suppr = Del<br/>
        ‚Ä¢ Scroll = Zoom
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0e27);

const canvas = document.getElementById('canvas');
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(12, 8, 12);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(10, 15, 10);
sun.castShadow = true;
sun.shadow.mapSize.set(1024, 1024);
scene.add(sun);

// Room
const floorGeo = new THREE.PlaneGeometry(10, 10);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x0f3460 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ color: 0x2a2a4e });

const leftWall = new THREE.Mesh(new THREE.BoxGeometry(10, 6, 0.2), wallMat);
leftWall.position.set(0, 3, -5.1);
leftWall.castShadow = true;
leftWall.receiveShadow = true;
scene.add(leftWall);

const backWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 6, 10), wallMat);
backWall.position.set(-5.1, 3, 0);
backWall.castShadow = true;
backWall.receiveShadow = true;
scene.add(backWall);

// Objects
const templates = {
    'Chaise': { icon: 'ü™ë', color: 0x8B4513, size: [0.5, 0.8, 0.5] },
    'Table': { icon: 'üõèÔ∏è', color: 0x654321, size: [1, 0.5, 1] },
    'Lampe': { icon: 'üí°', color: 0xFFD700, size: [0.2, 1, 0.2] },
    'Plante': { icon: 'üåø', color: 0x228B22, size: [0.3, 1, 0.3] },
    'Tableau': { icon: 'üñºÔ∏è', color: 0x8B7355, size: [0.1, 0.8, 1] },
    'Tapis': { icon: 'üßµ', color: 0xFF1493, size: [2, 0.05, 2] },
    'Miroir': { icon: 'ü™û', color: 0xC0C0C0, size: [0.1, 0.8, 0.8] },
    'Canap√©': { icon: 'üõãÔ∏è', color: 0xA9A9A9, size: [1.5, 0.6, 0.8] },
    'Bureau': { icon: 'üñ•Ô∏è', color: 0x8B4513, size: [1.2, 0.6, 0.8] },
    'Biblioth√®que': { icon: 'üìö', color: 0x654321, size: [1, 2, 0.4] },
    'T√©l√©vision': { icon: 'üì∫', color: 0x2F4F4F, size: [0.1, 0.8, 1.2] },
    'Horloge': { icon: 'üï∞Ô∏è', color: 0xDAA520, size: [0.1, 0.5, 0.5] },
    'Plante Grasse': { icon: 'üåµ', color: 0x90EE90, size: [0.4, 0.6, 0.4] },
    'Fleur': { icon: 'üå∏', color: 0xFF69B4, size: [0.3, 0.7, 0.3] },
    'Coussin': { icon: 'ü™°', color: 0xFF69B4, size: [0.4, 0.1, 0.4] },
    '√âtag√®re': { icon: 'üóÇÔ∏è', color: 0x8B4513, size: [1, 1.2, 0.3] },
    'Lampadaire': { icon: 'üèÆ', color: 0xFFD700, size: [0.15, 1.5, 0.15] },
    'Vase': { icon: 'üè∫', color: 0xCD853F, size: [0.3, 0.6, 0.3] },
    'Guitare': { icon: 'üé∏', color: 0xCD853F, size: [0.1, 0.8, 0.4] },
    'Piano': { icon: 'üéπ', color: 0x2F4F4F, size: [1.5, 0.4, 0.6] }
};

const objs = [];
let selected = null;
let draggingMode = 'move'; // 'move' ou 'rotate'

function addObj(type) {
    const t = templates[type];
    const [w, h, d] = t.size;
    const mat = new THREE.MeshStandardMaterial({ color: t.color, emissive: 0 });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
    mesh.position.set(Math.random() * 6 - 3, h / 2, Math.random() * 6 - 3);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData = { type, rotX: 0, rotY: 0, rotZ: 0 };
    scene.add(mesh);
    objs.push(mesh);
    updateCount();
}

function select(obj) {
    if (selected) selected.material.emissive.setHex(0x000000);
    selected = obj;
    if (obj) obj.material.emissive.setHex(0xFF0080);
}

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('click', (e) => {
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(objs);
    select(hits.length > 0 ? hits[0].object : null);
});

window.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' && selected) {
        scene.remove(selected);
        objs.splice(objs.indexOf(selected), 1);
        select(null);
        updateCount();
    }
    // R = Mode Rotation
    if (e.key === 'r' || e.key === 'R') {
        draggingMode = draggingMode === 'move' ? 'rotate' : 'move';
        console.log('Mode:', draggingMode);
    }
});

let drag = false, lastPos = { x: 0, y: 0 }, camAngle = { x: 0, y: 0 };

document.addEventListener('mousedown', (e) => { 
    drag = true; 
    lastPos = { x: e.clientX, y: e.clientY }; 
});

document.addEventListener('mousemove', (e) => {
    const dx = e.clientX - lastPos.x;
    const dy = e.clientY - lastPos.y;

    if (drag && !selected) {
        // Cam√©ra fluide et r√©active
        camAngle.y += dx * 0.008;
        camAngle.x = Math.max(-0.6, Math.min(0.6, camAngle.x + dy * 0.008));
        const d = 12;
        const camX = Math.sin(camAngle.y) * Math.cos(camAngle.x) * d;
        const camY = Math.sin(camAngle.x + Math.PI / 4) * d * 0.8;
        const camZ = Math.cos(camAngle.y) * Math.cos(camAngle.x) * d;
        camera.position.set(camX, camY, camZ);
        camera.lookAt(0, 0.5, 0);
    }

    if (drag && selected) {
        if (draggingMode === 'move') {
            // D√©placement en 2D XZ avec transformation bas√©e sur la cam√©ra
            const moveSpeed = 0.02;
            
            // Directions locales √† l'√©cran
            const screenDx = dx * moveSpeed;
            const screenDy = dy * moveSpeed;
            
            // Conversion en vecteurs mondiaux
            const rightVec = new THREE.Vector3(
                Math.cos(camAngle.y),
                0,
                Math.sin(camAngle.y)
            );
            const forwardVec = new THREE.Vector3(
                -Math.sin(camAngle.y),
                0,
                Math.cos(camAngle.y)
            );
            
            // Appliquer le mouvement (Y invers√©)
            selected.position.addScaledVector(rightVec, screenDx);
            selected.position.addScaledVector(forwardVec, screenDy);
            
            // Limites circulaires
            const maxDist = 4.8;
            const dist = Math.sqrt(selected.position.x ** 2 + selected.position.z ** 2);
            if (dist > maxDist) {
                const ratio = maxDist / dist;
                selected.position.x *= ratio;
                selected.position.z *= ratio;
            }
        } else if (draggingMode === 'rotate') {
            // Rotation fluide
            selected.userData.rotY += dx * 0.015;
            selected.userData.rotX += dy * 0.015;
            selected.rotation.order = 'YXZ';
            selected.rotation.y = selected.userData.rotY;
            selected.rotation.x = selected.userData.rotX;
        }
    }

    lastPos = { x: e.clientX, y: e.clientY };
});

document.addEventListener('mouseup', () => { drag = false; });

let zoom = 0;
document.addEventListener('wheel', (e) => { e.preventDefault(); zoom += e.deltaY * 0.01; }, { passive: false });

function resetCam() { camera.position.set(12, 8, 12); camera.lookAt(0, 0.5, 0); camAngle = { x: 0, y: 0 }; }
function clearRoom() { if (confirm('R√©initialiser la room?')) { objs.forEach(o => scene.remove(o)); objs.length = 0; select(null); updateCount(); } }
function saveRoom() { alert('‚úÖ Room sauvegard√©e!'); }
function updateCount() { document.getElementById('count').textContent = objs.length; }
function toggleRotate() { 
    draggingMode = draggingMode === 'move' ? 'rotate' : 'move'; 
    const btn = document.getElementById('rotBtn');
    const modeSpan = document.getElementById('mode');
    if (draggingMode === 'rotate') {
        btn.classList.add('active');
        btn.textContent = 'üîÄ Rotation';
        modeSpan.textContent = 'üîÄ Rotation';
    } else {
        btn.classList.remove('active');
        btn.textContent = 'üîÑ D√©plac.';
        modeSpan.textContent = 'Cam√©ra/D√©plac.';
    }
}

// UI Setup
Object.keys(templates).forEach(type => {
    const btn = document.createElement('button');
    btn.className = 'obj-btn';
    btn.textContent = templates[type].icon;
    btn.title = type;
    btn.onclick = () => addObj(type);
    document.getElementById('grid').appendChild(btn);
});

// Animation
let fps = 0, frames = 0, fpsTime = Date.now();

function animate() {
    requestAnimationFrame(animate);

    frames++;
    if (Date.now() >= fpsTime + 1000) {
        fps = frames;
        document.getElementById('fps').textContent = fps;
        frames = 0;
        fpsTime = Date.now();
    }

    // Zoom
    if (Math.abs(zoom) > 0.001) {
        const dist = Math.sqrt(camera.position.x ** 2 + camera.position.y ** 2 + camera.position.z ** 2);
        const newDist = Math.max(5, Math.min(30, dist + zoom * 50));
        const dir = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z).normalize();
        camera.position.copy(dir.multiplyScalar(newDist));
        camera.lookAt(0, 0, 0);
        zoom *= 0.9;
    }

    const pos = selected ? selected.position : camera.position;
    document.getElementById('pos').textContent = `${pos.x.toFixed(1)},${pos.y.toFixed(1)},${pos.z.toFixed(1)}`;

    if (selected) {
        const rotDeg = (selected.userData.rotY * 180 / Math.PI).toFixed(0);
        document.getElementById('rot').textContent = `${rotDeg}¬∞`;
    } else {
        document.getElementById('rot').textContent = '0¬∞';
    }

    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>

</body>
</html>
